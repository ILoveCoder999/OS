操作系统代码，尤其是内核（Kernel），传统上主要使用 **C 语言**编写，您对不能使用 C 标准库函数的理解是**非常正确**的。

以下是详细的原因解释：

### 1. 为什么使用 C 语言？

操作系统内核选择 C 语言是出于以下几个核心原因：

* **接近硬件 (Closeness to Hardware):** C 语言是一种“高级汇编语言”，它提供了对内存地址、位操作、寄存器等底层硬件的直接访问能力。这对于需要直接管理和控制硬件（如 CPU、内存、设备）的内核代码至关重要。
* **性能和效率 (Performance):** C 语言编译后产生的机器码执行效率高，运行速度快。在内核这种对性能要求极高的环境中，这是首选特性。
* **可移植性 (Portability):** C 语言的抽象层很薄，但它仍然比汇编语言更易于在不同 CPU 架构（如 x86、ARM 等）上移植和编译。
* **稳定性：** C 语言不像 C++ 有复杂的特性（如异常、RTTI、虚函数），这些特性在内核中难以管理和调试，容易引入不确定性。

### 2. 为什么不能用 C 的库函数？（需要自己写库函数）

这是最关键的一点。操作系统内核**不能**使用标准的 C 语言库（如 `stdio.h`、`malloc`、`printf` 等），主要原因如下：

* **内核的独立性（Self-Contained）:** 标准 C 库（如 Linux 下的 glibc）本身是**依赖于操作系统提供的服务**才能运行的。例如：
    * `printf` 依赖操作系统提供的 I/O 接口来打印到屏幕。
    * `malloc` 依赖操作系统提供的内存分配系统调用 (`sbrk` 或 `mmap`) 来获取内存。
    * **结论：** 内核是提供服务的那一方，它不能依赖于自己尚未提供的服务。
* **内存管理差异：** C 库的 `malloc` 在用户空间运行，管理用户进程的虚拟内存。内核必须使用自己的内存管理函数，例如您在 os161 代码中看到的 `kmalloc` (Kernel Malloc) 和 `kfree`，它们操作的是**内核的物理和虚拟地址空间**。
* **环境差异：** 标准 C 库需要一个初始化好的、完整的用户空间环境来运行。内核在系统启动的早期阶段就必须开始工作，那时用户空间还未建立。

**因此，结论是：**

操作系统内核需要自己实现一套**内核专用**的“库函数”，这包括：

* **内存管理函数：** `kmalloc`、`kfree` (您在代码中看到的)。
* **字符串/内存操作：** 重新实现或简化版的 `bzero`、`memcpy`、`strcpy` 等（通常在内核的 `lib.h` 中）。
* **调试和日志：** 类似 `kprintf` 或 `panic` 的内核专用打印/错误报告函数。
* **核心数据结构：** 比如您在代码中看到的 `array` 和 `bitmap`，内核必须自己设计这些高效且符合内核要求的结构。
